import { assert } from 'chai'
import DBEngine, { PostgresDBEngine } from './DBEngine'
import { Client } from 'pg'
import {
  PostgresLedgerChannelsDao,
  UpdateReason,
} from './dao/LedgerChannelsDao'
import Config from './Config'
import eraseDb from './testing/eraseDb'
import { PostgresVirtualChannelsDao } from './dao/VirtualChannelsDao'
import { PostgresChainsawLcDao, LcStatus } from './dao/ChainsawLcDao'
import LedgerChannelsService from './LedgerChannelService'
import { BigNumber } from 'bignumber.js'
import crypto = require('crypto')
import Web3 from 'web3'
import abi from './contract/channelManagerAbi'
import { LcStateUpdateDto } from './domain/LedgerChannel'
import {RedisClient} from './RedisClient'
import ChannelLocker from './ChannelLocker'
let func = process.env.DATABASE_URL_TEST ? describe : xdescribe
const tokenAbi = require('human-standard-token-abi')

func('LedgerChannelsService', () => {
  let client: DBEngine<Client>

  let postgresLedgerChannelsDao: PostgresLedgerChannelsDao
  let virtualChannelsDao: PostgresVirtualChannelsDao
  let chainsawDao: PostgresChainsawLcDao
  let ledgerChannelService: LedgerChannelsService
  let web3: any
  let config: Config
  let channelManager: any
  let tokenContract: any

  before(() => {
    client = new PostgresDBEngine({
      databaseUrl: process.env.DATABASE_URL_TEST,
    } as Config)
    postgresLedgerChannelsDao = new PostgresLedgerChannelsDao(client)
    chainsawDao = new PostgresChainsawLcDao(client)
    virtualChannelsDao = new PostgresVirtualChannelsDao(client)
    const port = process.env.ETH_PORT ? process.env.ETH_PORT : '8545'
    web3 = {}
    channelManager = {}
    tokenContract = {}

    ledgerChannelService = new LedgerChannelsService(
      virtualChannelsDao,
      postgresLedgerChannelsDao,
      chainsawDao,
      web3,
      channelManager,
      tokenContract,
      config,
      {} as RedisClient,
      {} as ChannelLocker
    )
    return client.connect()
  })

  after(() => {
    return client.disconnect()
  })

  beforeEach(async () => {
    await eraseDb(client)
    postgresLedgerChannelsDao = new PostgresLedgerChannelsDao(client)
    chainsawDao = new PostgresChainsawLcDao(client)
    virtualChannelsDao = new PostgresVirtualChannelsDao(client)
    ledgerChannelService = new LedgerChannelsService(
      virtualChannelsDao,
      postgresLedgerChannelsDao,
      chainsawDao,
      web3,
      channelManager,
      tokenContract,
      config,
      {} as RedisClient,
      {} as ChannelLocker
    )
  })

  afterEach(async () => {
    await eraseDb(client)
  })

  describe('open', () => {
    describe('#ledgerChannelById DidLCDeposit event partyI', () => {
      beforeEach(() => {
        return client.exec(async (c: Client) =>
          c.query(`
            INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
            VALUES(
             1,
            '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
            '0x6635303034316638353961653461376539613761653465306334383561343131',
             1,
             1,
             '0x66353030343166383539616534613765396137616534653063343835613431d1', 
             true,
             '0x821aea9a577a9b44299b9c15c88cf3087f3b5544',
             'DidLCOpen',
             '{"ethBalanceA": 1, "tokenBalanceA": 0, "token": "0x0000000000000000000000000000000000000000", "LCopenTimeout": 0}'::json
             );     
  
            INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
            VALUES(
             2,
            '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
            '0x6635303034316638353961653461376539613761653465306334383561343131',
             2,
             2,
             '0x66353030343166383539616534613765396137616534653063343835613431d1', 
             true,
             '0x2191ef87e392377ec08e7c08eb105ef5448eced5',
             'DidLCJoin',
             '{"ethBalanceI": 1, "tokenBalanceI": 0}'::json
             );
  
             INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
            VALUES(
             3,
            '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
            '0x6635303034316638353961653461376539613761653465306334383561343131',
             2,
             2,
             '0x66353030343166383539616534613765396137616534653063343835613431d1', 
             true,
             '0x2191ef87e392377ec08e7c08eb105ef5448eced5',
             'DidLCDeposit',
             '{"recipient": "0x821aea9a577a9b44299b9c15c88cf3087f3b5544", "deposit": 10}'::json
             );
          `),
        )
      })

      it('finds a returns the view with the correcrt data and check that ingrid has a balance equal to the amount recived in the event', async () => {
        const result = await ledgerChannelService.getById(
          '0x6635303034316638353961653461376539613761653465306334383561343131',
        )

        assert.deepEqual(result, {
          state: LcStatus.Opened,
          ethBalanceA: new BigNumber(11),
          ethBalanceI: new BigNumber(1),
          tokenBalanceA: new BigNumber(0),
          tokenBalanceI: new BigNumber(0),
          token: '0x0000000000000000000000000000000000000000',
          channelId:
            '0x6635303034316638353961653461376539613761653465306334383561343131',
          partyA: '0x821aea9a577a9b44299b9c15c88cf3087f3b5544',
          partyI: null as any,
          nonce: 0,
          vcRootHash:
            '0x0000000000000000000000000000000000000000000000000000000000000000',
          openVcs: 0,
          openTimeout: NaN,
          updateTimeout: NaN,
        })
      })
    })
    describe('join, add events', () => {
      describe('two channels and add events', () => {
        it('check balances and fast close', async () => {
          const channelId =
            '0xf9e2eaaa42d9fe9e558a9b8ef1bf366f190aacaa83bad2641ee106e9041096e4'
          const channelId2 =
            '0xf9e2eaaa42d9fe9e558a9b8ef1bf366f190aacaa83bad2641ee106e9041096e1'
          // insert ledger channel
          await client.exec((c: Client) =>
            c.query(
              `INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
              VALUES(
               1,
              '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
              '${channelId}',
               1,
               1,
               '0x66353030343166383539616534613765396137616534653063343835613431d1', 
               true,
               '0xfb3969f9dae19af76275bdcfb0748c836cd46fb2',
               'DidLCOpen',
               '{"ethBalanceA": 1, "tokenBalanceA": 0, "token": "0x0000000000000000000000000000000000000000", "LCopenTimeout": 0}'::json
               );

              INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
              VALUES(
                2,
              '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
                '${channelId}',
                2,
                2,
                '0x66353030343166383539616534613765396137616534653063343835613431d1', 
                true,
                '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
                'DidLCJoin',
                '{"ethBalanceI": 1, "tokenBalanceI": 0}'::json
                );`,
            ),
          )

          await client.exec((c: Client) =>
            c.query(
              `INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
                VALUES(
                3,
                '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
                '${channelId2}',
                1,
                1,
                '0x66353030343166383539616534613765396137616534653063343835613431d1', 
                true,
                '0xfb3969f9dae19af76275bdcfb0748c836cd46fb2',
                'DidLCOpen',
                '{"ethBalanceA": 200, "tokenBalanceA": 0, "token": "0x0000000000000000000000000000000000000000", "LCopenTimeout": 0}'::json
              );

              INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
                VALUES(
                  4,
                  '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
                  '${channelId2}',
                  2,
                  2,
                  '0x66353030343166383539616534613765396137616534653063343835613431d1', 
                  true,
                  '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
                  'DidLCJoin',
                  '{"ethBalanceI": 200, "tokenBalanceI": 0}'::json
                );
                
              INSERT INTO exchange_rates (retrievedat, base, rate_usd) VALUES (now_millis(), 0, 0);`,
            ),
          )

          const vcRootHash = await createRandomBytes32()
          const sigA = await createRandomBytes65()
          const sigI = await createRandomBytes65()

          let hubChannel = await ledgerChannelService.getById(channelId)

          let hubChannel2 = await ledgerChannelService.getById(channelId2)
          assert.deepEqual(hubChannel!.ethBalanceA, new BigNumber(1))
          assert.deepEqual(hubChannel!.ethBalanceI, new BigNumber(1))

          assert.deepEqual(hubChannel2!.ethBalanceA, new BigNumber(200))
          assert.deepEqual(hubChannel2!.ethBalanceI, new BigNumber(200))

          await postgresLedgerChannelsDao.createStateUpdate(channelId, {
            tokenBalanceA: new BigNumber(0),
            tokenBalanceI: new BigNumber(0),
            ethBalanceA: new BigNumber(150),
            ethBalanceI: new BigNumber(50),
            isClose: false,
            nonce: 1,
            openVcs: 0,
            vcRootHash,
            sigA,
            sigI,
            reason: UpdateReason.VcClosed,
          })

          await postgresLedgerChannelsDao.createStateUpdate(channelId2, {
            tokenBalanceA: new BigNumber(0),
            tokenBalanceI: new BigNumber(0),
            ethBalanceA: new BigNumber(100),
            ethBalanceI: new BigNumber(100),
            isClose: false,
            nonce: 1,
            openVcs: 0,
            vcRootHash,
            sigA,
            sigI,
            reason: UpdateReason.VcClosed,
          })

          hubChannel = await ledgerChannelService.getById(channelId)
          hubChannel2 = await ledgerChannelService.getById(channelId2)

          assert.deepEqual(hubChannel!.ethBalanceA, new BigNumber(150))
          assert.deepEqual(hubChannel!.ethBalanceI, new BigNumber(50))

          assert.deepEqual(hubChannel2!.ethBalanceA, new BigNumber(100))
          assert.deepEqual(hubChannel2!.ethBalanceI, new BigNumber(100))

          const stateUpdate2 = await postgresLedgerChannelsDao.createStateUpdate(
            channelId,
            {
              tokenBalanceA: new BigNumber(0),
              tokenBalanceI: new BigNumber(0),
              ethBalanceA: new BigNumber(100),
              ethBalanceI: new BigNumber(100),
              isClose: false,
              nonce: 2,
              openVcs: 0,
              vcRootHash,
              sigA,
              sigI,
              reason: UpdateReason.VcClosed,
            },
          )
        })
      })
    })
  })
})

async function createRandomBytes32(): Promise<any> {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(32, (err, buf) => {
      if (err) reject(err)
      resolve(`0x${buf.toString('hex')}`)
    })
  })
}

async function createRandomBytes65(): Promise<any> {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(65, (err, buf) => {
      if (err) reject(err)
      resolve(`0x${buf.toString('hex')}`)
    })
  })
}
