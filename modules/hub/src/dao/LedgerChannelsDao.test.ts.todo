import {assert} from 'chai'
import DBEngine, {PostgresDBEngine} from '../DBEngine'
import {Client} from 'pg'
import {PostgresLedgerChannelsDao, UpdateReason} from './LedgerChannelsDao'
import Config from '../Config'
import eraseDb from '../testing/eraseDb'
import {BigNumber} from 'bignumber.js'
import crypto = require('crypto')

let func = process.env.DATABASE_URL_TEST ? describe : xdescribe

func('LedgerChannelsDao', () => {
  let client: DBEngine<Client>

  let dao: PostgresLedgerChannelsDao

  before(() => {
    client = new PostgresDBEngine({
      databaseUrl: process.env.DATABASE_URL_TEST,
    } as Config)

    return client.connect()
  })

  after(() => {
    return client.disconnect()
  })

  beforeEach(async () => {
    await eraseDb(client)
    dao = new PostgresLedgerChannelsDao(client)
  })

  afterEach(async () => {
    await eraseDb(client)
  })

  describe('open', () => {
    beforeEach(() => {})

    it('should create and retrieve a state update', async () => {
      const channelId =
        '0xf9e2eaaa42d9fe9e558a9b8ef1bf366f190aacaa83bad2641ee106e9041096e4'
      // insert ledger channel
      await client.exec((c: Client) =>
        c.query(
          `INSERT INTO chainsaw_ledger_channels (
            contract,
            channel_id,
            wei_balance_a_chain, 
            wei_balance_i_chain,
            token,
            erc20_balance_a_chain, 
            erc20_balance_i_chain,
            on_chain_nonce, 
            vc_root_hash, 
            num_open_vc, 
            status
          ) VALUES (
            '0x821aea9a577a9b44299b9c15c88cf3087f3b5544',
            '${channelId}',
            100,
            200,
            '0x821aea9a577a9b44299b9c15c88cf3087f3b5544',
            0,
            0,
            0,
            '0xf9e2eaaa42d9fe9e558a9b8ef1bf366f190aacaa83bad2641ee106e9041096e4',
            0,
            'LCS_OPENED'
          );
          
          INSERT INTO exchange_rates (retrievedat, base, rate_usd) VALUES (now_millis(), 0, 0);`,
        ),
      )

      const vcRootHash = await createRandomBytes32()
      const sigA = await createRandomBytes65()
      const sigI = await createRandomBytes65()

      await dao.createStateUpdate(channelId, {
        ethBalanceA: new BigNumber(200),
        ethBalanceI: new BigNumber(100),
        tokenBalanceA: new BigNumber(10),
        tokenBalanceI: new BigNumber(20),
        isClose: false,
        nonce: 1,
        openVcs: 0,
        vcRootHash,
        sigA,
        sigI,
        reason: UpdateReason.VcOpened,
        priceWei: new BigNumber(100),
        priceToken: new BigNumber(10),
      })

      const stateUpdate = await dao.getStateUpdate(channelId, 1)
      assert.deepEqual(stateUpdate, {
        id: 1,
        channelId,
        ethBalanceA: new BigNumber(200),
        ethBalanceI: new BigNumber(100),
        tokenBalanceA: new BigNumber(10),
        tokenBalanceI: new BigNumber(20),
        isClose: false,
        nonce: 1,
        openVcs: 0,
        vcRootHash,
        sigA,
        sigI,
        priceWei: new BigNumber(100),
        priceToken: new BigNumber(10),
        reason: UpdateReason.LcPayment
      })
    })
  })
})

async function createRandomBytes32(): Promise<any> {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(32, (err, buf) => {
      if (err) reject(err)
      resolve(`0x${buf.toString('hex')}`)
    })
  })
}

async function createRandomBytes65(): Promise<any> {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(65, (err, buf) => {
      if (err) reject(err)
      resolve(`0x${buf.toString('hex')}`)
    })
  })
}
