import VirtualChannelsService from './VirtualChannelsService'
import { PostgresLedgerChannelsDao } from './dao/LedgerChannelsDao'
import DBEngine, { PostgresDBEngine } from './DBEngine'
import { Client } from 'pg'
import { PostgresVirtualChannelsDao } from './dao/VirtualChannelsDao'
import { PostgresChainsawLcDao } from './dao/ChainsawLcDao'
import LedgerChannelService from './LedgerChannelService'
import Config from './Config'
import eraseDb from './testing/eraseDb'
import crypto = require('crypto')
import { BigNumber } from 'bignumber.js'
import ChannelLocker from './ChannelLocker'

let func = process.env.DATABASE_URL_TEST ? describe : xdescribe

func('VirtualChannelsService', () => {
  let client: DBEngine<Client>

  let virtualChannelsDao: PostgresVirtualChannelsDao
  let chainsawDao: PostgresChainsawLcDao
  let ledgerChannelDao: PostgresLedgerChannelsDao
  let ledgerChannelService: LedgerChannelService
  let web3: any
  let config: Config
  let channelManager: any

  let virtualChannelsService: VirtualChannelsService

  let channel1: string, channel2: string

  before(() => {
    client = new PostgresDBEngine({
      databaseUrl: process.env.DATABASE_URL_TEST,
    } as Config)
    web3 = {}
    channelManager = {}

    virtualChannelsService = new VirtualChannelsService(
      virtualChannelsDao,
      ledgerChannelDao,
      chainsawDao,
      ledgerChannelService,
      web3,
      channelManager,
      config,
      { flagsFor: (addr: string): any => ({}) },
      {} as ChannelLocker
    )
    return client.connect()
  })

  after(() => {
    return client.disconnect()
  })

  beforeEach(async () => {
    await eraseDb(client)
  })

  afterEach(async () => {
    await eraseDb(client)
  })

  describe.skip('Virtual channel.', () => {
    it('Should autodeposit in a channel', async () => {
      channel1 =
        '0xf9e2eaaa42d9fe9e558a9b8ef1bf366f190aacaa83bad2641ee106e9041096e4'
      await client.exec(async (c: Client) =>
        c.query(`
        INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
        VALUES(
         1,
        '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
        '0x6635303034316638353961653461376539613761653465306334383561343131',
         1,
         1,
         '0x66353030343166383539616534613765396137616534653063343835613431d1', 
         true,
         '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
         'DidLCOpen',
         '{"ethBalanceA": 1, "tokenBalanceA": 0, "token": "0x0000000000000000000000000000000000000000", "LCopenTimeout": 0}'::json
         );
         
         INSERT INTO chainsaw_channel_events (id, contract, channel_id, ts, block_number, block_hash, is_valid_block, sender, event_type, fields)
          VALUES(
           2,
          '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
          '0x6635303034316638353961653461376539613761653465306334383561343131',
           2,
           2,
           '0x66353030343166383539616534613765396137616534653063343835613431d1', 
           true,
           '0xfa3969f9dae19af76275bdcfb0748c836cd46fb2',
           'DidLCJoin',
           '{"ethBalanceI": 1, "tokenBalanceI": 0}'::json
           );`),
      )
      console.log(virtualChannelsService)
      const vc = await virtualChannelsService.create(
        channel1,
        '0x821aea9a577a9b44299b9c15c88cf3087f3b5544',
        '0x2191ef87e392377ec08e7c08eb105ef5448eced5',
        new BigNumber(10),
        new BigNumber(0),
        '0x0',
        '0x0',
      )
      console.log(vc)
    })
  })
})

async function createRandomBytes32(): Promise<any> {
  return new Promise((resolve, reject) => {
    crypto.randomBytes(32, (err, buf) => {
      if (err) reject(err)
      resolve(`0x${buf.toString('hex')}`)
    })
  })
}
